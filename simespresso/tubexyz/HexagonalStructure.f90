!
!  HaxagonalStructure.f90
!
!  Free-Format Fortran Source File 
!  Generated by PGI Visual Fortran(R)
!  9/28/2011 1:02:23 AM
!

module HexagonalStructure
use Solvers
use class_HexPsi
use class_NanoTube
use SharedTypes

implicit none
contains

function GetPsi(n,m) result(psi)
	integer :: n,m
	real :: psi
	real :: Pi =  3.141592653589793
	type (PsiContainer) :: psic,psid
	real :: ZeroOfTransEq


	if (m.eq.0 ) then
		psi = Pi*(2*n+m)/(2*(n**2+n*m+m**2))+3*Pi**3*n*m**2*(n**2-m**2)*(2*n+m)*(n+2*m)/(32*(n**2+n*m+m**2)**5)
	else
		psic = make_HexPsiContainer(n,m)
		psi = NewtonRaphsonSafe(psic,0.0,Pi/n,1E-6)
	end if

end function GetPsi

function GetCosTheta(psi,n,m) result(cosTheta)
	real :: psi
	integer :: n,m
	real :: cosTheta
	real :: Pi =  3.141592653589793

	if (m.eq.0) then
		cosTheta=sqrt((n*(n+2*m)*sin(psi)**2)/((n+m)**2*sin(psi)**2))
	else
		cosTheta=sqrt((n*(n+2*m)*sin(psi)**2)/((n+m)**2*sin(psi)**2-m**2*sin(((n+m)*psi-Pi)/m)**2))
	end if

end function GetCosTheta

function GetSinOmega(psi,cosTheta) result(sinOmega)
	real :: psi
	real :: sinOmega
	real :: cosTheta
	real :: Pi =  3.141592653589793

	sinOmega = (sqrt((1/tan(psi))**2+4*cosTheta**2-3.0)-(1/tan(psi)))/(sqrt(3.0)*cosTheta)

end function GetSinOmega

function GetLambda(sinOmega,cosTheta) result (lambda)
	real :: sinOmega
	real :: cosTheta
	real :: lambda

	lambda = 1-sinomega**2*costheta**2

end function GetLambda

function GetMu(psi,sinOmega,cosTheta) result (mu)
	real :: sinOmega
	real :: cosTheta
	real :: psi
	real :: mu

	mu = 2*cos(asin(sinOmega))*costheta*(sinOmega*cosTheta+sqrt(3.0)*(1/tan(psi)))

end function GetMu


function GetNu(psi,sinOmega,cosTheta) result (nu)
	real :: sinOmega
	real :: cosTheta
	real :: psi
	real :: nu

	nu = 1-cosTheta**2*(4-sinOmega**2)+2*sqrt(3.0)*sinOmega*cosTheta*(1/tan(psi))

end function GetNu

function GetK(psi,cosTheta,sinOmega) result(k)
	real :: lambda,mu,nu
	real :: k,k1
	real :: psi,cosTheta
	real :: sinOmega

	mu = GetMu(psi,sinOmega,cosTheta)

	nu = GetNu(psi,sinOmega,cosTheta)

	lambda = GetLambda(sinOmega,cosTheta)

	k1 = (-mu+sqrt(mu**2-4*lambda*nu))/(2*lambda)
	
	if (k1.lt.0) then
		k = (-mu-sqrt(mu**2-4*lambda*nu))/(2*lambda)
	else
		k=k1
	end if

end function GetK

function GetRadius(tube,n,m,psi,cosTheta,sinOmega,k) result(r)
	type (NanoTube) :: tube
	real :: k,cosTheta,sinOmega,psi,r
	real :: sigma
	integer :: n,m
	real :: Pi =  3.141592653589793
	
	sigma = tube%Sigma

	if (m.eq.0) then
		r=(sigma*sqrt(3.0*(n**2.0+n*m+m**2.0))/(2.0*Pi)+sqrt(3.0)*sigma*Pi*(4.0*(n**2.0+n*m+m**2)**3.0-9.0*n**2.0*m**2.0*(n+m)**2.0) &
		/(64.0*(n**2.0+n*m+m**2.0)**(7.0/2.0)))
	else
		r=sigma*sqrt(3/(4+k**2))*cosTheta/sin(psi)
	end if

end function GetRadius



subroutine GetHexAtomsXYZ(tube,xyz)
	
	type (NanoTube) :: tube
	real :: k,cosTheta,sinOmega

	real , allocatable :: xyz(:,:,:,:)

	real :: Pi =  3.141592653589793
	real :: A(3),B(3),C(3),De(3)

	integer :: n,m,tubeLength
	real :: sinphi,Cof,sigma,psi
	real :: r

	m=tube%M
	n=tube%N
	tubeLength=tube%Length
	sigma = tube%Sigma

	psi = GetPsi(n,m)

	cosTheta = GetCosTheta(psi,n,m)
	sinOmega = GetSinOmega(psi,cosTheta)

	k = GetK(psi,cosTheta,sinOmega)

	r = GetRadius(tube,n,m,psi,cosTheta,sinOmega,k)

	sinphi=sqrt(3/(4+k**2))

	tube%Radius = r


	if (m.eq.0) then
		call GetZigZagConfiguration(tube,r,psi,sinphi,sigma,sinOmega,xyz)
	else
		call GetChiralAndArmchairConfiguration(tube,psi,cosTheta,sinOmega,k,r,sinphi,xyz)
	end if

end subroutine GetHexAtomsXYZ

subroutine GetChiralAndArmchairConfiguration(tube,psi,cosTheta,sinOmega,k,r,sinphi,xyz)

	type (NanoTube) :: tube
	real , allocatable :: xyz(:,:,:,:)

	real :: r,k,cosTheta,sinOmega
	real :: sinphi,Cof,sigma,psi
	real :: baseAtoms(3),outstandingAtoms(3)

	integer :: tubeLengthIndex,atomIndex

	integer :: n,m,tubeLength

	real :: Pi =  3.141592653589793
	real :: A(3),B(3),C(3),De(3)
	real :: CDeZ,CDeXY,ACZ,ACXY,ABZ,CHI,bee

	m=tube%M
	n=tube%N
	tubeLength=tube%Length
	sigma = tube%Sigma


	Cof=(sigma*sinphi/sqrt(3.0))

	A(1) = Cof*sqrt(3.0)*costheta
	A(2) = 0.0
	A(3) = Cof*(sqrt(3.0)*sin(acos(costheta)))

	B(1) = Cof*(-sqrt(3.0)*costheta)
	B(2) = 0.0
	B(3) = Cof*(-sqrt(3.0)*sin(acos(costheta)))
	
	C(1) = Cof*(3*sin(acos(costheta))*cos(asin(sinomega)))
	C(2) = Cof*(3*sinomega)
	C(3) = Cof*(-3*costheta*cos(asin(sinomega)))

	De(1) = Cof*(sin(acos(costheta))*(cos(asin(sinomega))-k*sinomega))
	De(2) = Cof*(k*cos(asin(sinomega))+sinomega)
	De(3) = Cof*(costheta*(k*sinomega-cos(asin(sinomega))))




	CDeZ=sqrt((C(3)-De(3))**2)
	CDeXY=sqrt((C(1)-De(1))**2+(C(2)-De(2))**2)
	ACZ=sqrt((A(3)-C(3))**2)
	ACXY=sqrt((A(1)-C(1))**2+(A(2)-C(2))**2)
	bee=sqrt((A(3)-B(3))**2)
	
 
	CHI=Pi-acos(0.5*(-2*r**2+CDeXY**2)/r**2)

	!call AllocateXYZArray(tube,xyz)

	do tubeLengthIndex=0,tubeLength
		do atomIndex=0,m-1

			baseAtoms = GetBaseAtoms(atomIndex,tubeLengthIndex,r,bee,n,m,psi)
			
			xyz(1,atomIndex+1,tubeLengthIndex+1,1) = baseAtoms(1)
			xyz(1,atomIndex+1,tubeLengthIndex+1,2) = baseAtoms(2)
			xyz(1,atomIndex+1,tubeLengthIndex+1,3) = baseAtoms(3)

			outstandingAtoms = GetOutstandingAtoms(atomIndex,tubeLengthIndex,r,bee,n,m,psi,CHI,CdeZ)

			xyz(2,atomIndex+1,tubeLengthIndex+1,1) = outstandingAtoms(1)
			xyz(2,atomIndex+1,tubeLengthIndex+1,2) = outstandingAtoms(2)
			xyz(2,atomIndex+1,tubeLengthIndex+1,3) = outstandingAtoms(3)

		end do
	end do

end subroutine GetChiralAndArmchairConfiguration

subroutine GetZigZagConfiguration(tube,r,psi,sinphi,sigma,sinOmega,xyz)

	type (NanoTube) :: tube
	real , allocatable :: xyz(:,:,:,:)
	real :: r,psi,sinphi,sigma,sinOmega

	integer :: n,m,tubeLength
	real :: baseAtoms(3)

	integer :: atomIndex,tubeLengthIndex

	m=tube%M
	n=tube%N
	tubeLength=tube%Length
	sigma = tube%Sigma

	!call AllocateXYZArray(tube,xyz)


	do tubeLengthIndex=0,tubeLength
		do atomIndex=0,n-1

			baseAtoms = GetBaseAtomsZigZag(atomIndex,tubeLengthIndex,r,psi,sinphi,sigma,sinOmega)
			
			xyz(1,atomIndex+1,tubeLengthIndex+1,1) = baseAtoms(1)
			xyz(1,atomIndex+1,tubeLengthIndex+1,2) = baseAtoms(2)
			xyz(1,atomIndex+1,tubeLengthIndex+1,3) = baseAtoms(3)

			xyz(2,atomIndex+1,tubeLengthIndex+1,1) = baseAtoms(1)
			xyz(2,atomIndex+1,tubeLengthIndex+1,2) = baseAtoms(2)
			xyz(2,atomIndex+1,tubeLengthIndex+1,3) = baseAtoms(3) + 2*sinphi*sigma/sqrt(3.0)

		end do
			
	end do

end subroutine GetZigZagConfiguration

function GetBaseAtoms(i,t,r,b,n,m,psi) result (baseAtoms)
	implicit none
	integer :: n,m,i,t
	real :: psi,r,b
	real :: baseAtoms(3)
	real :: Pi =  3.141592653589793


	baseAtoms(1) = r*cos(2*(psi*(t+i*n/m-(i*n/m))-i*Pi/m))
	baseAtoms(2) = r*sin(2*(psi*(t+i*n/m-(i*n/m))-i*Pi/m))
	baseAtoms(3) = (b*(t+i*n/m-(i*n/m)))

end function GetBaseAtoms

function GetBaseAtomsZigZag(i,t,r,psi,sinphi,sigma,sinOmega) result (baseAtoms)
	implicit none
	integer :: i,t
	real :: psi,sinphi,sigma,sinOmega,r
	real :: baseAtoms(3)
	real :: Pi =  3.141592653589793


	baseAtoms(1) =r*cos(psi*(2*i+t))
	baseAtoms(2) = r*sin(psi*(2*i+t))
	baseAtoms(3) = t*sinphi*sigma*sqrt(3.0)*cos(asin(sinOmega))

end function GetBaseAtomsZigZag

function GetOutstandingAtoms(i,t,r,b,n,m,psi,CHI,CdeZ) result (outstandingAtoms)
	implicit none
	integer :: n,m,i,t
	real :: psi,r,b
	real :: outstandingAtoms(3)
	real :: Pi =  3.141592653589793

	real :: CHI,CdeZ

	outstandingAtoms(1) = r*cos(2*(psi*(t+i*n/m-(i*n/m))-i*Pi/m)-CHI)
	outstandingAtoms(2) = r*sin(2*(psi*(t+i*n/m-(i*n/m))-i*Pi/m)-CHI)
	outstandingAtoms(3) = (b*(t+i*n/m-(i*n/m))+CDeZ)

end function GetOutstandingAtoms


end module







